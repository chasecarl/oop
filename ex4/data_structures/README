chasecarl
ilia.bezgin




=============================
=      File description     =
=============================
Tree.java - an implementation of a binary search tree
AvlTree.java - an implementation of an AVL tree


=============================
=          Design           =
=============================
We decided to write a super class of a binary search tree from which the AVL tree class inherits.
In our opinion, it's a good style programming because there is a clear 'is-a' relationship between
AVLT and BST, so if another programmer comes and wants to write other kind of BST, he or she will
already have the base class.
The thing that also points for this design is that we decided to write an inner class that
represents a node in BST and from the same reasoning it potentially has more potential (less restrictions)
comparing to something like AVL node. Even if they are the same, it's awkward to inherit a class for
some other type of BST node from an AVL node.



=============================
=  Implementation details   =
=============================
We decided to use our class that represents tree's node to store a whole tree.
We decided to put findMaxNodes in the base class because it is the same for BST as for AVL;
therefore we had to slightly change the comment so that the description matches to the class.
We decided to have boolean variables LEFT and RIGHT to alter methods' behaviour.
Our add method (in the base class) calls addHelper method that traverses through the nodes of the tree,
comparing node values with the given newValue, and using method go that in its turn again calls
addHelper on an appropriate child. At the end addHelper returns a new node, and go method also increments
height of all nodes on the recursion path if needed.
In the AvlTree, we call an addHelper and the method correction on the new node that addHelper just returned.
In the Tree class, an overloaded addHelper (that uses only one int value) can be called with either LEFT
or RIGHT - it doesn't matter.


=============================
=    Answers to questions   =
=============================

1)
The smart player picks his moves by simply looking at all the possible valid moves, and picking the
one that leaves the opponent with the minimal number of possible steps (and which does not make him lose)

2)
On the given example, the run time of the TresSet took 0.3445 seconds, While the run time of the HashSet took 0.56547.